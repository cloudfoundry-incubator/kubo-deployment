// Code generated by counterfeiter. DO NOT EDIT.
package releasedirfakes

import (
	"sync"

	boshrel "github.com/cloudfoundry/bosh-cli/release"
	boshpkg "github.com/cloudfoundry/bosh-cli/release/pkg"
	"github.com/cloudfoundry/bosh-cli/releasedir"
	semver "github.com/cppforlife/go-semi-semantic/version"
)

type FakeReleaseDir struct {
	InitStub        func(bool) error
	initMutex       sync.RWMutex
	initArgsForCall []struct {
		arg1 bool
	}
	initReturns struct {
		result1 error
	}
	initReturnsOnCall map[int]struct {
		result1 error
	}
	ResetStub        func() error
	resetMutex       sync.RWMutex
	resetArgsForCall []struct{}
	resetReturns     struct {
		result1 error
	}
	resetReturnsOnCall map[int]struct {
		result1 error
	}
	GenerateJobStub        func(string) error
	generateJobMutex       sync.RWMutex
	generateJobArgsForCall []struct {
		arg1 string
	}
	generateJobReturns struct {
		result1 error
	}
	generateJobReturnsOnCall map[int]struct {
		result1 error
	}
	GeneratePackageStub        func(string) error
	generatePackageMutex       sync.RWMutex
	generatePackageArgsForCall []struct {
		arg1 string
	}
	generatePackageReturns struct {
		result1 error
	}
	generatePackageReturnsOnCall map[int]struct {
		result1 error
	}
	DefaultNameStub        func() (string, error)
	defaultNameMutex       sync.RWMutex
	defaultNameArgsForCall []struct{}
	defaultNameReturns     struct {
		result1 string
		result2 error
	}
	defaultNameReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	NextDevVersionStub        func(name string, timestamp bool) (semver.Version, error)
	nextDevVersionMutex       sync.RWMutex
	nextDevVersionArgsForCall []struct {
		name      string
		timestamp bool
	}
	nextDevVersionReturns struct {
		result1 semver.Version
		result2 error
	}
	nextDevVersionReturnsOnCall map[int]struct {
		result1 semver.Version
		result2 error
	}
	NextFinalVersionStub        func(name string) (semver.Version, error)
	nextFinalVersionMutex       sync.RWMutex
	nextFinalVersionArgsForCall []struct {
		name string
	}
	nextFinalVersionReturns struct {
		result1 semver.Version
		result2 error
	}
	nextFinalVersionReturnsOnCall map[int]struct {
		result1 semver.Version
		result2 error
	}
	FindReleaseStub        func(name string, version semver.Version) (boshrel.Release, error)
	findReleaseMutex       sync.RWMutex
	findReleaseArgsForCall []struct {
		name    string
		version semver.Version
	}
	findReleaseReturns struct {
		result1 boshrel.Release
		result2 error
	}
	findReleaseReturnsOnCall map[int]struct {
		result1 boshrel.Release
		result2 error
	}
	BuildReleaseStub        func(name string, version semver.Version, force bool) (boshrel.Release, error)
	buildReleaseMutex       sync.RWMutex
	buildReleaseArgsForCall []struct {
		name    string
		version semver.Version
		force   bool
	}
	buildReleaseReturns struct {
		result1 boshrel.Release
		result2 error
	}
	buildReleaseReturnsOnCall map[int]struct {
		result1 boshrel.Release
		result2 error
	}
	VendorPackageStub        func(*boshpkg.Package) error
	vendorPackageMutex       sync.RWMutex
	vendorPackageArgsForCall []struct {
		arg1 *boshpkg.Package
	}
	vendorPackageReturns struct {
		result1 error
	}
	vendorPackageReturnsOnCall map[int]struct {
		result1 error
	}
	FinalizeReleaseStub        func(release boshrel.Release, force bool) error
	finalizeReleaseMutex       sync.RWMutex
	finalizeReleaseArgsForCall []struct {
		release boshrel.Release
		force   bool
	}
	finalizeReleaseReturns struct {
		result1 error
	}
	finalizeReleaseReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeReleaseDir) Init(arg1 bool) error {
	fake.initMutex.Lock()
	ret, specificReturn := fake.initReturnsOnCall[len(fake.initArgsForCall)]
	fake.initArgsForCall = append(fake.initArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("Init", []interface{}{arg1})
	fake.initMutex.Unlock()
	if fake.InitStub != nil {
		return fake.InitStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.initReturns.result1
}

func (fake *FakeReleaseDir) InitCallCount() int {
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	return len(fake.initArgsForCall)
}

func (fake *FakeReleaseDir) InitArgsForCall(i int) bool {
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	return fake.initArgsForCall[i].arg1
}

func (fake *FakeReleaseDir) InitReturns(result1 error) {
	fake.InitStub = nil
	fake.initReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeReleaseDir) InitReturnsOnCall(i int, result1 error) {
	fake.InitStub = nil
	if fake.initReturnsOnCall == nil {
		fake.initReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeReleaseDir) Reset() error {
	fake.resetMutex.Lock()
	ret, specificReturn := fake.resetReturnsOnCall[len(fake.resetArgsForCall)]
	fake.resetArgsForCall = append(fake.resetArgsForCall, struct{}{})
	fake.recordInvocation("Reset", []interface{}{})
	fake.resetMutex.Unlock()
	if fake.ResetStub != nil {
		return fake.ResetStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.resetReturns.result1
}

func (fake *FakeReleaseDir) ResetCallCount() int {
	fake.resetMutex.RLock()
	defer fake.resetMutex.RUnlock()
	return len(fake.resetArgsForCall)
}

func (fake *FakeReleaseDir) ResetReturns(result1 error) {
	fake.ResetStub = nil
	fake.resetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeReleaseDir) ResetReturnsOnCall(i int, result1 error) {
	fake.ResetStub = nil
	if fake.resetReturnsOnCall == nil {
		fake.resetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeReleaseDir) GenerateJob(arg1 string) error {
	fake.generateJobMutex.Lock()
	ret, specificReturn := fake.generateJobReturnsOnCall[len(fake.generateJobArgsForCall)]
	fake.generateJobArgsForCall = append(fake.generateJobArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GenerateJob", []interface{}{arg1})
	fake.generateJobMutex.Unlock()
	if fake.GenerateJobStub != nil {
		return fake.GenerateJobStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.generateJobReturns.result1
}

func (fake *FakeReleaseDir) GenerateJobCallCount() int {
	fake.generateJobMutex.RLock()
	defer fake.generateJobMutex.RUnlock()
	return len(fake.generateJobArgsForCall)
}

func (fake *FakeReleaseDir) GenerateJobArgsForCall(i int) string {
	fake.generateJobMutex.RLock()
	defer fake.generateJobMutex.RUnlock()
	return fake.generateJobArgsForCall[i].arg1
}

func (fake *FakeReleaseDir) GenerateJobReturns(result1 error) {
	fake.GenerateJobStub = nil
	fake.generateJobReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeReleaseDir) GenerateJobReturnsOnCall(i int, result1 error) {
	fake.GenerateJobStub = nil
	if fake.generateJobReturnsOnCall == nil {
		fake.generateJobReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.generateJobReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeReleaseDir) GeneratePackage(arg1 string) error {
	fake.generatePackageMutex.Lock()
	ret, specificReturn := fake.generatePackageReturnsOnCall[len(fake.generatePackageArgsForCall)]
	fake.generatePackageArgsForCall = append(fake.generatePackageArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GeneratePackage", []interface{}{arg1})
	fake.generatePackageMutex.Unlock()
	if fake.GeneratePackageStub != nil {
		return fake.GeneratePackageStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.generatePackageReturns.result1
}

func (fake *FakeReleaseDir) GeneratePackageCallCount() int {
	fake.generatePackageMutex.RLock()
	defer fake.generatePackageMutex.RUnlock()
	return len(fake.generatePackageArgsForCall)
}

func (fake *FakeReleaseDir) GeneratePackageArgsForCall(i int) string {
	fake.generatePackageMutex.RLock()
	defer fake.generatePackageMutex.RUnlock()
	return fake.generatePackageArgsForCall[i].arg1
}

func (fake *FakeReleaseDir) GeneratePackageReturns(result1 error) {
	fake.GeneratePackageStub = nil
	fake.generatePackageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeReleaseDir) GeneratePackageReturnsOnCall(i int, result1 error) {
	fake.GeneratePackageStub = nil
	if fake.generatePackageReturnsOnCall == nil {
		fake.generatePackageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.generatePackageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeReleaseDir) DefaultName() (string, error) {
	fake.defaultNameMutex.Lock()
	ret, specificReturn := fake.defaultNameReturnsOnCall[len(fake.defaultNameArgsForCall)]
	fake.defaultNameArgsForCall = append(fake.defaultNameArgsForCall, struct{}{})
	fake.recordInvocation("DefaultName", []interface{}{})
	fake.defaultNameMutex.Unlock()
	if fake.DefaultNameStub != nil {
		return fake.DefaultNameStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.defaultNameReturns.result1, fake.defaultNameReturns.result2
}

func (fake *FakeReleaseDir) DefaultNameCallCount() int {
	fake.defaultNameMutex.RLock()
	defer fake.defaultNameMutex.RUnlock()
	return len(fake.defaultNameArgsForCall)
}

func (fake *FakeReleaseDir) DefaultNameReturns(result1 string, result2 error) {
	fake.DefaultNameStub = nil
	fake.defaultNameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeReleaseDir) DefaultNameReturnsOnCall(i int, result1 string, result2 error) {
	fake.DefaultNameStub = nil
	if fake.defaultNameReturnsOnCall == nil {
		fake.defaultNameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.defaultNameReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeReleaseDir) NextDevVersion(name string, timestamp bool) (semver.Version, error) {
	fake.nextDevVersionMutex.Lock()
	ret, specificReturn := fake.nextDevVersionReturnsOnCall[len(fake.nextDevVersionArgsForCall)]
	fake.nextDevVersionArgsForCall = append(fake.nextDevVersionArgsForCall, struct {
		name      string
		timestamp bool
	}{name, timestamp})
	fake.recordInvocation("NextDevVersion", []interface{}{name, timestamp})
	fake.nextDevVersionMutex.Unlock()
	if fake.NextDevVersionStub != nil {
		return fake.NextDevVersionStub(name, timestamp)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.nextDevVersionReturns.result1, fake.nextDevVersionReturns.result2
}

func (fake *FakeReleaseDir) NextDevVersionCallCount() int {
	fake.nextDevVersionMutex.RLock()
	defer fake.nextDevVersionMutex.RUnlock()
	return len(fake.nextDevVersionArgsForCall)
}

func (fake *FakeReleaseDir) NextDevVersionArgsForCall(i int) (string, bool) {
	fake.nextDevVersionMutex.RLock()
	defer fake.nextDevVersionMutex.RUnlock()
	return fake.nextDevVersionArgsForCall[i].name, fake.nextDevVersionArgsForCall[i].timestamp
}

func (fake *FakeReleaseDir) NextDevVersionReturns(result1 semver.Version, result2 error) {
	fake.NextDevVersionStub = nil
	fake.nextDevVersionReturns = struct {
		result1 semver.Version
		result2 error
	}{result1, result2}
}

func (fake *FakeReleaseDir) NextDevVersionReturnsOnCall(i int, result1 semver.Version, result2 error) {
	fake.NextDevVersionStub = nil
	if fake.nextDevVersionReturnsOnCall == nil {
		fake.nextDevVersionReturnsOnCall = make(map[int]struct {
			result1 semver.Version
			result2 error
		})
	}
	fake.nextDevVersionReturnsOnCall[i] = struct {
		result1 semver.Version
		result2 error
	}{result1, result2}
}

func (fake *FakeReleaseDir) NextFinalVersion(name string) (semver.Version, error) {
	fake.nextFinalVersionMutex.Lock()
	ret, specificReturn := fake.nextFinalVersionReturnsOnCall[len(fake.nextFinalVersionArgsForCall)]
	fake.nextFinalVersionArgsForCall = append(fake.nextFinalVersionArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("NextFinalVersion", []interface{}{name})
	fake.nextFinalVersionMutex.Unlock()
	if fake.NextFinalVersionStub != nil {
		return fake.NextFinalVersionStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.nextFinalVersionReturns.result1, fake.nextFinalVersionReturns.result2
}

func (fake *FakeReleaseDir) NextFinalVersionCallCount() int {
	fake.nextFinalVersionMutex.RLock()
	defer fake.nextFinalVersionMutex.RUnlock()
	return len(fake.nextFinalVersionArgsForCall)
}

func (fake *FakeReleaseDir) NextFinalVersionArgsForCall(i int) string {
	fake.nextFinalVersionMutex.RLock()
	defer fake.nextFinalVersionMutex.RUnlock()
	return fake.nextFinalVersionArgsForCall[i].name
}

func (fake *FakeReleaseDir) NextFinalVersionReturns(result1 semver.Version, result2 error) {
	fake.NextFinalVersionStub = nil
	fake.nextFinalVersionReturns = struct {
		result1 semver.Version
		result2 error
	}{result1, result2}
}

func (fake *FakeReleaseDir) NextFinalVersionReturnsOnCall(i int, result1 semver.Version, result2 error) {
	fake.NextFinalVersionStub = nil
	if fake.nextFinalVersionReturnsOnCall == nil {
		fake.nextFinalVersionReturnsOnCall = make(map[int]struct {
			result1 semver.Version
			result2 error
		})
	}
	fake.nextFinalVersionReturnsOnCall[i] = struct {
		result1 semver.Version
		result2 error
	}{result1, result2}
}

func (fake *FakeReleaseDir) FindRelease(name string, version semver.Version) (boshrel.Release, error) {
	fake.findReleaseMutex.Lock()
	ret, specificReturn := fake.findReleaseReturnsOnCall[len(fake.findReleaseArgsForCall)]
	fake.findReleaseArgsForCall = append(fake.findReleaseArgsForCall, struct {
		name    string
		version semver.Version
	}{name, version})
	fake.recordInvocation("FindRelease", []interface{}{name, version})
	fake.findReleaseMutex.Unlock()
	if fake.FindReleaseStub != nil {
		return fake.FindReleaseStub(name, version)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findReleaseReturns.result1, fake.findReleaseReturns.result2
}

func (fake *FakeReleaseDir) FindReleaseCallCount() int {
	fake.findReleaseMutex.RLock()
	defer fake.findReleaseMutex.RUnlock()
	return len(fake.findReleaseArgsForCall)
}

func (fake *FakeReleaseDir) FindReleaseArgsForCall(i int) (string, semver.Version) {
	fake.findReleaseMutex.RLock()
	defer fake.findReleaseMutex.RUnlock()
	return fake.findReleaseArgsForCall[i].name, fake.findReleaseArgsForCall[i].version
}

func (fake *FakeReleaseDir) FindReleaseReturns(result1 boshrel.Release, result2 error) {
	fake.FindReleaseStub = nil
	fake.findReleaseReturns = struct {
		result1 boshrel.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeReleaseDir) FindReleaseReturnsOnCall(i int, result1 boshrel.Release, result2 error) {
	fake.FindReleaseStub = nil
	if fake.findReleaseReturnsOnCall == nil {
		fake.findReleaseReturnsOnCall = make(map[int]struct {
			result1 boshrel.Release
			result2 error
		})
	}
	fake.findReleaseReturnsOnCall[i] = struct {
		result1 boshrel.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeReleaseDir) BuildRelease(name string, version semver.Version, force bool) (boshrel.Release, error) {
	fake.buildReleaseMutex.Lock()
	ret, specificReturn := fake.buildReleaseReturnsOnCall[len(fake.buildReleaseArgsForCall)]
	fake.buildReleaseArgsForCall = append(fake.buildReleaseArgsForCall, struct {
		name    string
		version semver.Version
		force   bool
	}{name, version, force})
	fake.recordInvocation("BuildRelease", []interface{}{name, version, force})
	fake.buildReleaseMutex.Unlock()
	if fake.BuildReleaseStub != nil {
		return fake.BuildReleaseStub(name, version, force)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.buildReleaseReturns.result1, fake.buildReleaseReturns.result2
}

func (fake *FakeReleaseDir) BuildReleaseCallCount() int {
	fake.buildReleaseMutex.RLock()
	defer fake.buildReleaseMutex.RUnlock()
	return len(fake.buildReleaseArgsForCall)
}

func (fake *FakeReleaseDir) BuildReleaseArgsForCall(i int) (string, semver.Version, bool) {
	fake.buildReleaseMutex.RLock()
	defer fake.buildReleaseMutex.RUnlock()
	return fake.buildReleaseArgsForCall[i].name, fake.buildReleaseArgsForCall[i].version, fake.buildReleaseArgsForCall[i].force
}

func (fake *FakeReleaseDir) BuildReleaseReturns(result1 boshrel.Release, result2 error) {
	fake.BuildReleaseStub = nil
	fake.buildReleaseReturns = struct {
		result1 boshrel.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeReleaseDir) BuildReleaseReturnsOnCall(i int, result1 boshrel.Release, result2 error) {
	fake.BuildReleaseStub = nil
	if fake.buildReleaseReturnsOnCall == nil {
		fake.buildReleaseReturnsOnCall = make(map[int]struct {
			result1 boshrel.Release
			result2 error
		})
	}
	fake.buildReleaseReturnsOnCall[i] = struct {
		result1 boshrel.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeReleaseDir) VendorPackage(arg1 *boshpkg.Package) error {
	fake.vendorPackageMutex.Lock()
	ret, specificReturn := fake.vendorPackageReturnsOnCall[len(fake.vendorPackageArgsForCall)]
	fake.vendorPackageArgsForCall = append(fake.vendorPackageArgsForCall, struct {
		arg1 *boshpkg.Package
	}{arg1})
	fake.recordInvocation("VendorPackage", []interface{}{arg1})
	fake.vendorPackageMutex.Unlock()
	if fake.VendorPackageStub != nil {
		return fake.VendorPackageStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.vendorPackageReturns.result1
}

func (fake *FakeReleaseDir) VendorPackageCallCount() int {
	fake.vendorPackageMutex.RLock()
	defer fake.vendorPackageMutex.RUnlock()
	return len(fake.vendorPackageArgsForCall)
}

func (fake *FakeReleaseDir) VendorPackageArgsForCall(i int) *boshpkg.Package {
	fake.vendorPackageMutex.RLock()
	defer fake.vendorPackageMutex.RUnlock()
	return fake.vendorPackageArgsForCall[i].arg1
}

func (fake *FakeReleaseDir) VendorPackageReturns(result1 error) {
	fake.VendorPackageStub = nil
	fake.vendorPackageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeReleaseDir) VendorPackageReturnsOnCall(i int, result1 error) {
	fake.VendorPackageStub = nil
	if fake.vendorPackageReturnsOnCall == nil {
		fake.vendorPackageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.vendorPackageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeReleaseDir) FinalizeRelease(release boshrel.Release, force bool) error {
	fake.finalizeReleaseMutex.Lock()
	ret, specificReturn := fake.finalizeReleaseReturnsOnCall[len(fake.finalizeReleaseArgsForCall)]
	fake.finalizeReleaseArgsForCall = append(fake.finalizeReleaseArgsForCall, struct {
		release boshrel.Release
		force   bool
	}{release, force})
	fake.recordInvocation("FinalizeRelease", []interface{}{release, force})
	fake.finalizeReleaseMutex.Unlock()
	if fake.FinalizeReleaseStub != nil {
		return fake.FinalizeReleaseStub(release, force)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.finalizeReleaseReturns.result1
}

func (fake *FakeReleaseDir) FinalizeReleaseCallCount() int {
	fake.finalizeReleaseMutex.RLock()
	defer fake.finalizeReleaseMutex.RUnlock()
	return len(fake.finalizeReleaseArgsForCall)
}

func (fake *FakeReleaseDir) FinalizeReleaseArgsForCall(i int) (boshrel.Release, bool) {
	fake.finalizeReleaseMutex.RLock()
	defer fake.finalizeReleaseMutex.RUnlock()
	return fake.finalizeReleaseArgsForCall[i].release, fake.finalizeReleaseArgsForCall[i].force
}

func (fake *FakeReleaseDir) FinalizeReleaseReturns(result1 error) {
	fake.FinalizeReleaseStub = nil
	fake.finalizeReleaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeReleaseDir) FinalizeReleaseReturnsOnCall(i int, result1 error) {
	fake.FinalizeReleaseStub = nil
	if fake.finalizeReleaseReturnsOnCall == nil {
		fake.finalizeReleaseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.finalizeReleaseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeReleaseDir) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	fake.resetMutex.RLock()
	defer fake.resetMutex.RUnlock()
	fake.generateJobMutex.RLock()
	defer fake.generateJobMutex.RUnlock()
	fake.generatePackageMutex.RLock()
	defer fake.generatePackageMutex.RUnlock()
	fake.defaultNameMutex.RLock()
	defer fake.defaultNameMutex.RUnlock()
	fake.nextDevVersionMutex.RLock()
	defer fake.nextDevVersionMutex.RUnlock()
	fake.nextFinalVersionMutex.RLock()
	defer fake.nextFinalVersionMutex.RUnlock()
	fake.findReleaseMutex.RLock()
	defer fake.findReleaseMutex.RUnlock()
	fake.buildReleaseMutex.RLock()
	defer fake.buildReleaseMutex.RUnlock()
	fake.vendorPackageMutex.RLock()
	defer fake.vendorPackageMutex.RUnlock()
	fake.finalizeReleaseMutex.RLock()
	defer fake.finalizeReleaseMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeReleaseDir) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ releasedir.ReleaseDir = new(FakeReleaseDir)
