// Code generated by counterfeiter. DO NOT EDIT.
package directorfakes

import (
	"sync"
	"time"

	"github.com/cloudfoundry/bosh-cli/director"
)

type FakeOrphanDisk struct {
	CIDStub        func() string
	cIDMutex       sync.RWMutex
	cIDArgsForCall []struct{}
	cIDReturns     struct {
		result1 string
	}
	cIDReturnsOnCall map[int]struct {
		result1 string
	}
	SizeStub        func() uint64
	sizeMutex       sync.RWMutex
	sizeArgsForCall []struct{}
	sizeReturns     struct {
		result1 uint64
	}
	sizeReturnsOnCall map[int]struct {
		result1 uint64
	}
	DeploymentStub        func() director.Deployment
	deploymentMutex       sync.RWMutex
	deploymentArgsForCall []struct{}
	deploymentReturns     struct {
		result1 director.Deployment
	}
	deploymentReturnsOnCall map[int]struct {
		result1 director.Deployment
	}
	InstanceNameStub        func() string
	instanceNameMutex       sync.RWMutex
	instanceNameArgsForCall []struct{}
	instanceNameReturns     struct {
		result1 string
	}
	instanceNameReturnsOnCall map[int]struct {
		result1 string
	}
	AZNameStub        func() string
	aZNameMutex       sync.RWMutex
	aZNameArgsForCall []struct{}
	aZNameReturns     struct {
		result1 string
	}
	aZNameReturnsOnCall map[int]struct {
		result1 string
	}
	OrphanedAtStub        func() time.Time
	orphanedAtMutex       sync.RWMutex
	orphanedAtArgsForCall []struct{}
	orphanedAtReturns     struct {
		result1 time.Time
	}
	orphanedAtReturnsOnCall map[int]struct {
		result1 time.Time
	}
	DeleteStub        func() error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct{}
	deleteReturns     struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeOrphanDisk) CID() string {
	fake.cIDMutex.Lock()
	ret, specificReturn := fake.cIDReturnsOnCall[len(fake.cIDArgsForCall)]
	fake.cIDArgsForCall = append(fake.cIDArgsForCall, struct{}{})
	fake.recordInvocation("CID", []interface{}{})
	fake.cIDMutex.Unlock()
	if fake.CIDStub != nil {
		return fake.CIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cIDReturns.result1
}

func (fake *FakeOrphanDisk) CIDCallCount() int {
	fake.cIDMutex.RLock()
	defer fake.cIDMutex.RUnlock()
	return len(fake.cIDArgsForCall)
}

func (fake *FakeOrphanDisk) CIDReturns(result1 string) {
	fake.CIDStub = nil
	fake.cIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeOrphanDisk) CIDReturnsOnCall(i int, result1 string) {
	fake.CIDStub = nil
	if fake.cIDReturnsOnCall == nil {
		fake.cIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.cIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeOrphanDisk) Size() uint64 {
	fake.sizeMutex.Lock()
	ret, specificReturn := fake.sizeReturnsOnCall[len(fake.sizeArgsForCall)]
	fake.sizeArgsForCall = append(fake.sizeArgsForCall, struct{}{})
	fake.recordInvocation("Size", []interface{}{})
	fake.sizeMutex.Unlock()
	if fake.SizeStub != nil {
		return fake.SizeStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.sizeReturns.result1
}

func (fake *FakeOrphanDisk) SizeCallCount() int {
	fake.sizeMutex.RLock()
	defer fake.sizeMutex.RUnlock()
	return len(fake.sizeArgsForCall)
}

func (fake *FakeOrphanDisk) SizeReturns(result1 uint64) {
	fake.SizeStub = nil
	fake.sizeReturns = struct {
		result1 uint64
	}{result1}
}

func (fake *FakeOrphanDisk) SizeReturnsOnCall(i int, result1 uint64) {
	fake.SizeStub = nil
	if fake.sizeReturnsOnCall == nil {
		fake.sizeReturnsOnCall = make(map[int]struct {
			result1 uint64
		})
	}
	fake.sizeReturnsOnCall[i] = struct {
		result1 uint64
	}{result1}
}

func (fake *FakeOrphanDisk) Deployment() director.Deployment {
	fake.deploymentMutex.Lock()
	ret, specificReturn := fake.deploymentReturnsOnCall[len(fake.deploymentArgsForCall)]
	fake.deploymentArgsForCall = append(fake.deploymentArgsForCall, struct{}{})
	fake.recordInvocation("Deployment", []interface{}{})
	fake.deploymentMutex.Unlock()
	if fake.DeploymentStub != nil {
		return fake.DeploymentStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deploymentReturns.result1
}

func (fake *FakeOrphanDisk) DeploymentCallCount() int {
	fake.deploymentMutex.RLock()
	defer fake.deploymentMutex.RUnlock()
	return len(fake.deploymentArgsForCall)
}

func (fake *FakeOrphanDisk) DeploymentReturns(result1 director.Deployment) {
	fake.DeploymentStub = nil
	fake.deploymentReturns = struct {
		result1 director.Deployment
	}{result1}
}

func (fake *FakeOrphanDisk) DeploymentReturnsOnCall(i int, result1 director.Deployment) {
	fake.DeploymentStub = nil
	if fake.deploymentReturnsOnCall == nil {
		fake.deploymentReturnsOnCall = make(map[int]struct {
			result1 director.Deployment
		})
	}
	fake.deploymentReturnsOnCall[i] = struct {
		result1 director.Deployment
	}{result1}
}

func (fake *FakeOrphanDisk) InstanceName() string {
	fake.instanceNameMutex.Lock()
	ret, specificReturn := fake.instanceNameReturnsOnCall[len(fake.instanceNameArgsForCall)]
	fake.instanceNameArgsForCall = append(fake.instanceNameArgsForCall, struct{}{})
	fake.recordInvocation("InstanceName", []interface{}{})
	fake.instanceNameMutex.Unlock()
	if fake.InstanceNameStub != nil {
		return fake.InstanceNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.instanceNameReturns.result1
}

func (fake *FakeOrphanDisk) InstanceNameCallCount() int {
	fake.instanceNameMutex.RLock()
	defer fake.instanceNameMutex.RUnlock()
	return len(fake.instanceNameArgsForCall)
}

func (fake *FakeOrphanDisk) InstanceNameReturns(result1 string) {
	fake.InstanceNameStub = nil
	fake.instanceNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeOrphanDisk) InstanceNameReturnsOnCall(i int, result1 string) {
	fake.InstanceNameStub = nil
	if fake.instanceNameReturnsOnCall == nil {
		fake.instanceNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.instanceNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeOrphanDisk) AZName() string {
	fake.aZNameMutex.Lock()
	ret, specificReturn := fake.aZNameReturnsOnCall[len(fake.aZNameArgsForCall)]
	fake.aZNameArgsForCall = append(fake.aZNameArgsForCall, struct{}{})
	fake.recordInvocation("AZName", []interface{}{})
	fake.aZNameMutex.Unlock()
	if fake.AZNameStub != nil {
		return fake.AZNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.aZNameReturns.result1
}

func (fake *FakeOrphanDisk) AZNameCallCount() int {
	fake.aZNameMutex.RLock()
	defer fake.aZNameMutex.RUnlock()
	return len(fake.aZNameArgsForCall)
}

func (fake *FakeOrphanDisk) AZNameReturns(result1 string) {
	fake.AZNameStub = nil
	fake.aZNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeOrphanDisk) AZNameReturnsOnCall(i int, result1 string) {
	fake.AZNameStub = nil
	if fake.aZNameReturnsOnCall == nil {
		fake.aZNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.aZNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeOrphanDisk) OrphanedAt() time.Time {
	fake.orphanedAtMutex.Lock()
	ret, specificReturn := fake.orphanedAtReturnsOnCall[len(fake.orphanedAtArgsForCall)]
	fake.orphanedAtArgsForCall = append(fake.orphanedAtArgsForCall, struct{}{})
	fake.recordInvocation("OrphanedAt", []interface{}{})
	fake.orphanedAtMutex.Unlock()
	if fake.OrphanedAtStub != nil {
		return fake.OrphanedAtStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.orphanedAtReturns.result1
}

func (fake *FakeOrphanDisk) OrphanedAtCallCount() int {
	fake.orphanedAtMutex.RLock()
	defer fake.orphanedAtMutex.RUnlock()
	return len(fake.orphanedAtArgsForCall)
}

func (fake *FakeOrphanDisk) OrphanedAtReturns(result1 time.Time) {
	fake.OrphanedAtStub = nil
	fake.orphanedAtReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeOrphanDisk) OrphanedAtReturnsOnCall(i int, result1 time.Time) {
	fake.OrphanedAtStub = nil
	if fake.orphanedAtReturnsOnCall == nil {
		fake.orphanedAtReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.orphanedAtReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeOrphanDisk) Delete() error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct{}{})
	fake.recordInvocation("Delete", []interface{}{})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteReturns.result1
}

func (fake *FakeOrphanDisk) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeOrphanDisk) DeleteReturns(result1 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOrphanDisk) DeleteReturnsOnCall(i int, result1 error) {
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOrphanDisk) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cIDMutex.RLock()
	defer fake.cIDMutex.RUnlock()
	fake.sizeMutex.RLock()
	defer fake.sizeMutex.RUnlock()
	fake.deploymentMutex.RLock()
	defer fake.deploymentMutex.RUnlock()
	fake.instanceNameMutex.RLock()
	defer fake.instanceNameMutex.RUnlock()
	fake.aZNameMutex.RLock()
	defer fake.aZNameMutex.RUnlock()
	fake.orphanedAtMutex.RLock()
	defer fake.orphanedAtMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeOrphanDisk) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ director.OrphanDisk = new(FakeOrphanDisk)
