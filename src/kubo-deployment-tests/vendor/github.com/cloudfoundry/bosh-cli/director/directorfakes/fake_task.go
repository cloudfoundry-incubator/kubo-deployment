// Code generated by counterfeiter. DO NOT EDIT.
package directorfakes

import (
	"sync"
	"time"

	"github.com/cloudfoundry/bosh-cli/director"
)

type FakeTask struct {
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct{}
	iDReturns     struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	StartedAtStub        func() time.Time
	startedAtMutex       sync.RWMutex
	startedAtArgsForCall []struct{}
	startedAtReturns     struct {
		result1 time.Time
	}
	startedAtReturnsOnCall map[int]struct {
		result1 time.Time
	}
	LastActivityAtStub        func() time.Time
	lastActivityAtMutex       sync.RWMutex
	lastActivityAtArgsForCall []struct{}
	lastActivityAtReturns     struct {
		result1 time.Time
	}
	lastActivityAtReturnsOnCall map[int]struct {
		result1 time.Time
	}
	StateStub        func() string
	stateMutex       sync.RWMutex
	stateArgsForCall []struct{}
	stateReturns     struct {
		result1 string
	}
	stateReturnsOnCall map[int]struct {
		result1 string
	}
	IsErrorStub        func() bool
	isErrorMutex       sync.RWMutex
	isErrorArgsForCall []struct{}
	isErrorReturns     struct {
		result1 bool
	}
	isErrorReturnsOnCall map[int]struct {
		result1 bool
	}
	UserStub        func() string
	userMutex       sync.RWMutex
	userArgsForCall []struct{}
	userReturns     struct {
		result1 string
	}
	userReturnsOnCall map[int]struct {
		result1 string
	}
	DeploymentNameStub        func() string
	deploymentNameMutex       sync.RWMutex
	deploymentNameArgsForCall []struct{}
	deploymentNameReturns     struct {
		result1 string
	}
	deploymentNameReturnsOnCall map[int]struct {
		result1 string
	}
	ContextIDStub        func() string
	contextIDMutex       sync.RWMutex
	contextIDArgsForCall []struct{}
	contextIDReturns     struct {
		result1 string
	}
	contextIDReturnsOnCall map[int]struct {
		result1 string
	}
	DescriptionStub        func() string
	descriptionMutex       sync.RWMutex
	descriptionArgsForCall []struct{}
	descriptionReturns     struct {
		result1 string
	}
	descriptionReturnsOnCall map[int]struct {
		result1 string
	}
	ResultStub        func() string
	resultMutex       sync.RWMutex
	resultArgsForCall []struct{}
	resultReturns     struct {
		result1 string
	}
	resultReturnsOnCall map[int]struct {
		result1 string
	}
	EventOutputStub        func(director.TaskReporter) error
	eventOutputMutex       sync.RWMutex
	eventOutputArgsForCall []struct {
		arg1 director.TaskReporter
	}
	eventOutputReturns struct {
		result1 error
	}
	eventOutputReturnsOnCall map[int]struct {
		result1 error
	}
	CPIOutputStub        func(director.TaskReporter) error
	cPIOutputMutex       sync.RWMutex
	cPIOutputArgsForCall []struct {
		arg1 director.TaskReporter
	}
	cPIOutputReturns struct {
		result1 error
	}
	cPIOutputReturnsOnCall map[int]struct {
		result1 error
	}
	DebugOutputStub        func(director.TaskReporter) error
	debugOutputMutex       sync.RWMutex
	debugOutputArgsForCall []struct {
		arg1 director.TaskReporter
	}
	debugOutputReturns struct {
		result1 error
	}
	debugOutputReturnsOnCall map[int]struct {
		result1 error
	}
	ResultOutputStub        func(director.TaskReporter) error
	resultOutputMutex       sync.RWMutex
	resultOutputArgsForCall []struct {
		arg1 director.TaskReporter
	}
	resultOutputReturns struct {
		result1 error
	}
	resultOutputReturnsOnCall map[int]struct {
		result1 error
	}
	CancelStub        func() error
	cancelMutex       sync.RWMutex
	cancelArgsForCall []struct{}
	cancelReturns     struct {
		result1 error
	}
	cancelReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTask) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct{}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iDReturns.result1
}

func (fake *FakeTask) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeTask) IDReturns(result1 int) {
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeTask) IDReturnsOnCall(i int, result1 int) {
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeTask) StartedAt() time.Time {
	fake.startedAtMutex.Lock()
	ret, specificReturn := fake.startedAtReturnsOnCall[len(fake.startedAtArgsForCall)]
	fake.startedAtArgsForCall = append(fake.startedAtArgsForCall, struct{}{})
	fake.recordInvocation("StartedAt", []interface{}{})
	fake.startedAtMutex.Unlock()
	if fake.StartedAtStub != nil {
		return fake.StartedAtStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.startedAtReturns.result1
}

func (fake *FakeTask) StartedAtCallCount() int {
	fake.startedAtMutex.RLock()
	defer fake.startedAtMutex.RUnlock()
	return len(fake.startedAtArgsForCall)
}

func (fake *FakeTask) StartedAtReturns(result1 time.Time) {
	fake.StartedAtStub = nil
	fake.startedAtReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeTask) StartedAtReturnsOnCall(i int, result1 time.Time) {
	fake.StartedAtStub = nil
	if fake.startedAtReturnsOnCall == nil {
		fake.startedAtReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.startedAtReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeTask) LastActivityAt() time.Time {
	fake.lastActivityAtMutex.Lock()
	ret, specificReturn := fake.lastActivityAtReturnsOnCall[len(fake.lastActivityAtArgsForCall)]
	fake.lastActivityAtArgsForCall = append(fake.lastActivityAtArgsForCall, struct{}{})
	fake.recordInvocation("LastActivityAt", []interface{}{})
	fake.lastActivityAtMutex.Unlock()
	if fake.LastActivityAtStub != nil {
		return fake.LastActivityAtStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.lastActivityAtReturns.result1
}

func (fake *FakeTask) LastActivityAtCallCount() int {
	fake.lastActivityAtMutex.RLock()
	defer fake.lastActivityAtMutex.RUnlock()
	return len(fake.lastActivityAtArgsForCall)
}

func (fake *FakeTask) LastActivityAtReturns(result1 time.Time) {
	fake.LastActivityAtStub = nil
	fake.lastActivityAtReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeTask) LastActivityAtReturnsOnCall(i int, result1 time.Time) {
	fake.LastActivityAtStub = nil
	if fake.lastActivityAtReturnsOnCall == nil {
		fake.lastActivityAtReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.lastActivityAtReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeTask) State() string {
	fake.stateMutex.Lock()
	ret, specificReturn := fake.stateReturnsOnCall[len(fake.stateArgsForCall)]
	fake.stateArgsForCall = append(fake.stateArgsForCall, struct{}{})
	fake.recordInvocation("State", []interface{}{})
	fake.stateMutex.Unlock()
	if fake.StateStub != nil {
		return fake.StateStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.stateReturns.result1
}

func (fake *FakeTask) StateCallCount() int {
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	return len(fake.stateArgsForCall)
}

func (fake *FakeTask) StateReturns(result1 string) {
	fake.StateStub = nil
	fake.stateReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) StateReturnsOnCall(i int, result1 string) {
	fake.StateStub = nil
	if fake.stateReturnsOnCall == nil {
		fake.stateReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.stateReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) IsError() bool {
	fake.isErrorMutex.Lock()
	ret, specificReturn := fake.isErrorReturnsOnCall[len(fake.isErrorArgsForCall)]
	fake.isErrorArgsForCall = append(fake.isErrorArgsForCall, struct{}{})
	fake.recordInvocation("IsError", []interface{}{})
	fake.isErrorMutex.Unlock()
	if fake.IsErrorStub != nil {
		return fake.IsErrorStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isErrorReturns.result1
}

func (fake *FakeTask) IsErrorCallCount() int {
	fake.isErrorMutex.RLock()
	defer fake.isErrorMutex.RUnlock()
	return len(fake.isErrorArgsForCall)
}

func (fake *FakeTask) IsErrorReturns(result1 bool) {
	fake.IsErrorStub = nil
	fake.isErrorReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeTask) IsErrorReturnsOnCall(i int, result1 bool) {
	fake.IsErrorStub = nil
	if fake.isErrorReturnsOnCall == nil {
		fake.isErrorReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isErrorReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeTask) User() string {
	fake.userMutex.Lock()
	ret, specificReturn := fake.userReturnsOnCall[len(fake.userArgsForCall)]
	fake.userArgsForCall = append(fake.userArgsForCall, struct{}{})
	fake.recordInvocation("User", []interface{}{})
	fake.userMutex.Unlock()
	if fake.UserStub != nil {
		return fake.UserStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.userReturns.result1
}

func (fake *FakeTask) UserCallCount() int {
	fake.userMutex.RLock()
	defer fake.userMutex.RUnlock()
	return len(fake.userArgsForCall)
}

func (fake *FakeTask) UserReturns(result1 string) {
	fake.UserStub = nil
	fake.userReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) UserReturnsOnCall(i int, result1 string) {
	fake.UserStub = nil
	if fake.userReturnsOnCall == nil {
		fake.userReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.userReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) DeploymentName() string {
	fake.deploymentNameMutex.Lock()
	ret, specificReturn := fake.deploymentNameReturnsOnCall[len(fake.deploymentNameArgsForCall)]
	fake.deploymentNameArgsForCall = append(fake.deploymentNameArgsForCall, struct{}{})
	fake.recordInvocation("DeploymentName", []interface{}{})
	fake.deploymentNameMutex.Unlock()
	if fake.DeploymentNameStub != nil {
		return fake.DeploymentNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deploymentNameReturns.result1
}

func (fake *FakeTask) DeploymentNameCallCount() int {
	fake.deploymentNameMutex.RLock()
	defer fake.deploymentNameMutex.RUnlock()
	return len(fake.deploymentNameArgsForCall)
}

func (fake *FakeTask) DeploymentNameReturns(result1 string) {
	fake.DeploymentNameStub = nil
	fake.deploymentNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) DeploymentNameReturnsOnCall(i int, result1 string) {
	fake.DeploymentNameStub = nil
	if fake.deploymentNameReturnsOnCall == nil {
		fake.deploymentNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.deploymentNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) ContextID() string {
	fake.contextIDMutex.Lock()
	ret, specificReturn := fake.contextIDReturnsOnCall[len(fake.contextIDArgsForCall)]
	fake.contextIDArgsForCall = append(fake.contextIDArgsForCall, struct{}{})
	fake.recordInvocation("ContextID", []interface{}{})
	fake.contextIDMutex.Unlock()
	if fake.ContextIDStub != nil {
		return fake.ContextIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.contextIDReturns.result1
}

func (fake *FakeTask) ContextIDCallCount() int {
	fake.contextIDMutex.RLock()
	defer fake.contextIDMutex.RUnlock()
	return len(fake.contextIDArgsForCall)
}

func (fake *FakeTask) ContextIDReturns(result1 string) {
	fake.ContextIDStub = nil
	fake.contextIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) ContextIDReturnsOnCall(i int, result1 string) {
	fake.ContextIDStub = nil
	if fake.contextIDReturnsOnCall == nil {
		fake.contextIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.contextIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) Description() string {
	fake.descriptionMutex.Lock()
	ret, specificReturn := fake.descriptionReturnsOnCall[len(fake.descriptionArgsForCall)]
	fake.descriptionArgsForCall = append(fake.descriptionArgsForCall, struct{}{})
	fake.recordInvocation("Description", []interface{}{})
	fake.descriptionMutex.Unlock()
	if fake.DescriptionStub != nil {
		return fake.DescriptionStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.descriptionReturns.result1
}

func (fake *FakeTask) DescriptionCallCount() int {
	fake.descriptionMutex.RLock()
	defer fake.descriptionMutex.RUnlock()
	return len(fake.descriptionArgsForCall)
}

func (fake *FakeTask) DescriptionReturns(result1 string) {
	fake.DescriptionStub = nil
	fake.descriptionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) DescriptionReturnsOnCall(i int, result1 string) {
	fake.DescriptionStub = nil
	if fake.descriptionReturnsOnCall == nil {
		fake.descriptionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.descriptionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) Result() string {
	fake.resultMutex.Lock()
	ret, specificReturn := fake.resultReturnsOnCall[len(fake.resultArgsForCall)]
	fake.resultArgsForCall = append(fake.resultArgsForCall, struct{}{})
	fake.recordInvocation("Result", []interface{}{})
	fake.resultMutex.Unlock()
	if fake.ResultStub != nil {
		return fake.ResultStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.resultReturns.result1
}

func (fake *FakeTask) ResultCallCount() int {
	fake.resultMutex.RLock()
	defer fake.resultMutex.RUnlock()
	return len(fake.resultArgsForCall)
}

func (fake *FakeTask) ResultReturns(result1 string) {
	fake.ResultStub = nil
	fake.resultReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) ResultReturnsOnCall(i int, result1 string) {
	fake.ResultStub = nil
	if fake.resultReturnsOnCall == nil {
		fake.resultReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.resultReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) EventOutput(arg1 director.TaskReporter) error {
	fake.eventOutputMutex.Lock()
	ret, specificReturn := fake.eventOutputReturnsOnCall[len(fake.eventOutputArgsForCall)]
	fake.eventOutputArgsForCall = append(fake.eventOutputArgsForCall, struct {
		arg1 director.TaskReporter
	}{arg1})
	fake.recordInvocation("EventOutput", []interface{}{arg1})
	fake.eventOutputMutex.Unlock()
	if fake.EventOutputStub != nil {
		return fake.EventOutputStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.eventOutputReturns.result1
}

func (fake *FakeTask) EventOutputCallCount() int {
	fake.eventOutputMutex.RLock()
	defer fake.eventOutputMutex.RUnlock()
	return len(fake.eventOutputArgsForCall)
}

func (fake *FakeTask) EventOutputArgsForCall(i int) director.TaskReporter {
	fake.eventOutputMutex.RLock()
	defer fake.eventOutputMutex.RUnlock()
	return fake.eventOutputArgsForCall[i].arg1
}

func (fake *FakeTask) EventOutputReturns(result1 error) {
	fake.EventOutputStub = nil
	fake.eventOutputReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) EventOutputReturnsOnCall(i int, result1 error) {
	fake.EventOutputStub = nil
	if fake.eventOutputReturnsOnCall == nil {
		fake.eventOutputReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.eventOutputReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) CPIOutput(arg1 director.TaskReporter) error {
	fake.cPIOutputMutex.Lock()
	ret, specificReturn := fake.cPIOutputReturnsOnCall[len(fake.cPIOutputArgsForCall)]
	fake.cPIOutputArgsForCall = append(fake.cPIOutputArgsForCall, struct {
		arg1 director.TaskReporter
	}{arg1})
	fake.recordInvocation("CPIOutput", []interface{}{arg1})
	fake.cPIOutputMutex.Unlock()
	if fake.CPIOutputStub != nil {
		return fake.CPIOutputStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cPIOutputReturns.result1
}

func (fake *FakeTask) CPIOutputCallCount() int {
	fake.cPIOutputMutex.RLock()
	defer fake.cPIOutputMutex.RUnlock()
	return len(fake.cPIOutputArgsForCall)
}

func (fake *FakeTask) CPIOutputArgsForCall(i int) director.TaskReporter {
	fake.cPIOutputMutex.RLock()
	defer fake.cPIOutputMutex.RUnlock()
	return fake.cPIOutputArgsForCall[i].arg1
}

func (fake *FakeTask) CPIOutputReturns(result1 error) {
	fake.CPIOutputStub = nil
	fake.cPIOutputReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) CPIOutputReturnsOnCall(i int, result1 error) {
	fake.CPIOutputStub = nil
	if fake.cPIOutputReturnsOnCall == nil {
		fake.cPIOutputReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cPIOutputReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) DebugOutput(arg1 director.TaskReporter) error {
	fake.debugOutputMutex.Lock()
	ret, specificReturn := fake.debugOutputReturnsOnCall[len(fake.debugOutputArgsForCall)]
	fake.debugOutputArgsForCall = append(fake.debugOutputArgsForCall, struct {
		arg1 director.TaskReporter
	}{arg1})
	fake.recordInvocation("DebugOutput", []interface{}{arg1})
	fake.debugOutputMutex.Unlock()
	if fake.DebugOutputStub != nil {
		return fake.DebugOutputStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.debugOutputReturns.result1
}

func (fake *FakeTask) DebugOutputCallCount() int {
	fake.debugOutputMutex.RLock()
	defer fake.debugOutputMutex.RUnlock()
	return len(fake.debugOutputArgsForCall)
}

func (fake *FakeTask) DebugOutputArgsForCall(i int) director.TaskReporter {
	fake.debugOutputMutex.RLock()
	defer fake.debugOutputMutex.RUnlock()
	return fake.debugOutputArgsForCall[i].arg1
}

func (fake *FakeTask) DebugOutputReturns(result1 error) {
	fake.DebugOutputStub = nil
	fake.debugOutputReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) DebugOutputReturnsOnCall(i int, result1 error) {
	fake.DebugOutputStub = nil
	if fake.debugOutputReturnsOnCall == nil {
		fake.debugOutputReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.debugOutputReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) ResultOutput(arg1 director.TaskReporter) error {
	fake.resultOutputMutex.Lock()
	ret, specificReturn := fake.resultOutputReturnsOnCall[len(fake.resultOutputArgsForCall)]
	fake.resultOutputArgsForCall = append(fake.resultOutputArgsForCall, struct {
		arg1 director.TaskReporter
	}{arg1})
	fake.recordInvocation("ResultOutput", []interface{}{arg1})
	fake.resultOutputMutex.Unlock()
	if fake.ResultOutputStub != nil {
		return fake.ResultOutputStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.resultOutputReturns.result1
}

func (fake *FakeTask) ResultOutputCallCount() int {
	fake.resultOutputMutex.RLock()
	defer fake.resultOutputMutex.RUnlock()
	return len(fake.resultOutputArgsForCall)
}

func (fake *FakeTask) ResultOutputArgsForCall(i int) director.TaskReporter {
	fake.resultOutputMutex.RLock()
	defer fake.resultOutputMutex.RUnlock()
	return fake.resultOutputArgsForCall[i].arg1
}

func (fake *FakeTask) ResultOutputReturns(result1 error) {
	fake.ResultOutputStub = nil
	fake.resultOutputReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) ResultOutputReturnsOnCall(i int, result1 error) {
	fake.ResultOutputStub = nil
	if fake.resultOutputReturnsOnCall == nil {
		fake.resultOutputReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resultOutputReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) Cancel() error {
	fake.cancelMutex.Lock()
	ret, specificReturn := fake.cancelReturnsOnCall[len(fake.cancelArgsForCall)]
	fake.cancelArgsForCall = append(fake.cancelArgsForCall, struct{}{})
	fake.recordInvocation("Cancel", []interface{}{})
	fake.cancelMutex.Unlock()
	if fake.CancelStub != nil {
		return fake.CancelStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cancelReturns.result1
}

func (fake *FakeTask) CancelCallCount() int {
	fake.cancelMutex.RLock()
	defer fake.cancelMutex.RUnlock()
	return len(fake.cancelArgsForCall)
}

func (fake *FakeTask) CancelReturns(result1 error) {
	fake.CancelStub = nil
	fake.cancelReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) CancelReturnsOnCall(i int, result1 error) {
	fake.CancelStub = nil
	if fake.cancelReturnsOnCall == nil {
		fake.cancelReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.startedAtMutex.RLock()
	defer fake.startedAtMutex.RUnlock()
	fake.lastActivityAtMutex.RLock()
	defer fake.lastActivityAtMutex.RUnlock()
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	fake.isErrorMutex.RLock()
	defer fake.isErrorMutex.RUnlock()
	fake.userMutex.RLock()
	defer fake.userMutex.RUnlock()
	fake.deploymentNameMutex.RLock()
	defer fake.deploymentNameMutex.RUnlock()
	fake.contextIDMutex.RLock()
	defer fake.contextIDMutex.RUnlock()
	fake.descriptionMutex.RLock()
	defer fake.descriptionMutex.RUnlock()
	fake.resultMutex.RLock()
	defer fake.resultMutex.RUnlock()
	fake.eventOutputMutex.RLock()
	defer fake.eventOutputMutex.RUnlock()
	fake.cPIOutputMutex.RLock()
	defer fake.cPIOutputMutex.RUnlock()
	fake.debugOutputMutex.RLock()
	defer fake.debugOutputMutex.RUnlock()
	fake.resultOutputMutex.RLock()
	defer fake.resultOutputMutex.RUnlock()
	fake.cancelMutex.RLock()
	defer fake.cancelMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTask) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ director.Task = new(FakeTask)
