// Code generated by counterfeiter. DO NOT EDIT.
package directorfakes

import (
	"sync"
	"time"

	"github.com/cloudfoundry/bosh-cli/director"
)

type FakeEvent struct {
	IDStub        func() string
	iDMutex       sync.RWMutex
	iDArgsForCall []struct{}
	iDReturns     struct {
		result1 string
	}
	iDReturnsOnCall map[int]struct {
		result1 string
	}
	ParentIDStub        func() string
	parentIDMutex       sync.RWMutex
	parentIDArgsForCall []struct{}
	parentIDReturns     struct {
		result1 string
	}
	parentIDReturnsOnCall map[int]struct {
		result1 string
	}
	TimestampStub        func() time.Time
	timestampMutex       sync.RWMutex
	timestampArgsForCall []struct{}
	timestampReturns     struct {
		result1 time.Time
	}
	timestampReturnsOnCall map[int]struct {
		result1 time.Time
	}
	UserStub        func() string
	userMutex       sync.RWMutex
	userArgsForCall []struct{}
	userReturns     struct {
		result1 string
	}
	userReturnsOnCall map[int]struct {
		result1 string
	}
	ActionStub        func() string
	actionMutex       sync.RWMutex
	actionArgsForCall []struct{}
	actionReturns     struct {
		result1 string
	}
	actionReturnsOnCall map[int]struct {
		result1 string
	}
	ObjectTypeStub        func() string
	objectTypeMutex       sync.RWMutex
	objectTypeArgsForCall []struct{}
	objectTypeReturns     struct {
		result1 string
	}
	objectTypeReturnsOnCall map[int]struct {
		result1 string
	}
	ObjectNameStub        func() string
	objectNameMutex       sync.RWMutex
	objectNameArgsForCall []struct{}
	objectNameReturns     struct {
		result1 string
	}
	objectNameReturnsOnCall map[int]struct {
		result1 string
	}
	TaskIDStub        func() string
	taskIDMutex       sync.RWMutex
	taskIDArgsForCall []struct{}
	taskIDReturns     struct {
		result1 string
	}
	taskIDReturnsOnCall map[int]struct {
		result1 string
	}
	DeploymentNameStub        func() string
	deploymentNameMutex       sync.RWMutex
	deploymentNameArgsForCall []struct{}
	deploymentNameReturns     struct {
		result1 string
	}
	deploymentNameReturnsOnCall map[int]struct {
		result1 string
	}
	InstanceStub        func() string
	instanceMutex       sync.RWMutex
	instanceArgsForCall []struct{}
	instanceReturns     struct {
		result1 string
	}
	instanceReturnsOnCall map[int]struct {
		result1 string
	}
	ContextStub        func() map[string]interface{}
	contextMutex       sync.RWMutex
	contextArgsForCall []struct{}
	contextReturns     struct {
		result1 map[string]interface{}
	}
	contextReturnsOnCall map[int]struct {
		result1 map[string]interface{}
	}
	ErrorStub        func() string
	errorMutex       sync.RWMutex
	errorArgsForCall []struct{}
	errorReturns     struct {
		result1 string
	}
	errorReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeEvent) ID() string {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct{}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iDReturns.result1
}

func (fake *FakeEvent) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeEvent) IDReturns(result1 string) {
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeEvent) IDReturnsOnCall(i int, result1 string) {
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeEvent) ParentID() string {
	fake.parentIDMutex.Lock()
	ret, specificReturn := fake.parentIDReturnsOnCall[len(fake.parentIDArgsForCall)]
	fake.parentIDArgsForCall = append(fake.parentIDArgsForCall, struct{}{})
	fake.recordInvocation("ParentID", []interface{}{})
	fake.parentIDMutex.Unlock()
	if fake.ParentIDStub != nil {
		return fake.ParentIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.parentIDReturns.result1
}

func (fake *FakeEvent) ParentIDCallCount() int {
	fake.parentIDMutex.RLock()
	defer fake.parentIDMutex.RUnlock()
	return len(fake.parentIDArgsForCall)
}

func (fake *FakeEvent) ParentIDReturns(result1 string) {
	fake.ParentIDStub = nil
	fake.parentIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeEvent) ParentIDReturnsOnCall(i int, result1 string) {
	fake.ParentIDStub = nil
	if fake.parentIDReturnsOnCall == nil {
		fake.parentIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.parentIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeEvent) Timestamp() time.Time {
	fake.timestampMutex.Lock()
	ret, specificReturn := fake.timestampReturnsOnCall[len(fake.timestampArgsForCall)]
	fake.timestampArgsForCall = append(fake.timestampArgsForCall, struct{}{})
	fake.recordInvocation("Timestamp", []interface{}{})
	fake.timestampMutex.Unlock()
	if fake.TimestampStub != nil {
		return fake.TimestampStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.timestampReturns.result1
}

func (fake *FakeEvent) TimestampCallCount() int {
	fake.timestampMutex.RLock()
	defer fake.timestampMutex.RUnlock()
	return len(fake.timestampArgsForCall)
}

func (fake *FakeEvent) TimestampReturns(result1 time.Time) {
	fake.TimestampStub = nil
	fake.timestampReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeEvent) TimestampReturnsOnCall(i int, result1 time.Time) {
	fake.TimestampStub = nil
	if fake.timestampReturnsOnCall == nil {
		fake.timestampReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.timestampReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeEvent) User() string {
	fake.userMutex.Lock()
	ret, specificReturn := fake.userReturnsOnCall[len(fake.userArgsForCall)]
	fake.userArgsForCall = append(fake.userArgsForCall, struct{}{})
	fake.recordInvocation("User", []interface{}{})
	fake.userMutex.Unlock()
	if fake.UserStub != nil {
		return fake.UserStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.userReturns.result1
}

func (fake *FakeEvent) UserCallCount() int {
	fake.userMutex.RLock()
	defer fake.userMutex.RUnlock()
	return len(fake.userArgsForCall)
}

func (fake *FakeEvent) UserReturns(result1 string) {
	fake.UserStub = nil
	fake.userReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeEvent) UserReturnsOnCall(i int, result1 string) {
	fake.UserStub = nil
	if fake.userReturnsOnCall == nil {
		fake.userReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.userReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeEvent) Action() string {
	fake.actionMutex.Lock()
	ret, specificReturn := fake.actionReturnsOnCall[len(fake.actionArgsForCall)]
	fake.actionArgsForCall = append(fake.actionArgsForCall, struct{}{})
	fake.recordInvocation("Action", []interface{}{})
	fake.actionMutex.Unlock()
	if fake.ActionStub != nil {
		return fake.ActionStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.actionReturns.result1
}

func (fake *FakeEvent) ActionCallCount() int {
	fake.actionMutex.RLock()
	defer fake.actionMutex.RUnlock()
	return len(fake.actionArgsForCall)
}

func (fake *FakeEvent) ActionReturns(result1 string) {
	fake.ActionStub = nil
	fake.actionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeEvent) ActionReturnsOnCall(i int, result1 string) {
	fake.ActionStub = nil
	if fake.actionReturnsOnCall == nil {
		fake.actionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.actionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeEvent) ObjectType() string {
	fake.objectTypeMutex.Lock()
	ret, specificReturn := fake.objectTypeReturnsOnCall[len(fake.objectTypeArgsForCall)]
	fake.objectTypeArgsForCall = append(fake.objectTypeArgsForCall, struct{}{})
	fake.recordInvocation("ObjectType", []interface{}{})
	fake.objectTypeMutex.Unlock()
	if fake.ObjectTypeStub != nil {
		return fake.ObjectTypeStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.objectTypeReturns.result1
}

func (fake *FakeEvent) ObjectTypeCallCount() int {
	fake.objectTypeMutex.RLock()
	defer fake.objectTypeMutex.RUnlock()
	return len(fake.objectTypeArgsForCall)
}

func (fake *FakeEvent) ObjectTypeReturns(result1 string) {
	fake.ObjectTypeStub = nil
	fake.objectTypeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeEvent) ObjectTypeReturnsOnCall(i int, result1 string) {
	fake.ObjectTypeStub = nil
	if fake.objectTypeReturnsOnCall == nil {
		fake.objectTypeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.objectTypeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeEvent) ObjectName() string {
	fake.objectNameMutex.Lock()
	ret, specificReturn := fake.objectNameReturnsOnCall[len(fake.objectNameArgsForCall)]
	fake.objectNameArgsForCall = append(fake.objectNameArgsForCall, struct{}{})
	fake.recordInvocation("ObjectName", []interface{}{})
	fake.objectNameMutex.Unlock()
	if fake.ObjectNameStub != nil {
		return fake.ObjectNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.objectNameReturns.result1
}

func (fake *FakeEvent) ObjectNameCallCount() int {
	fake.objectNameMutex.RLock()
	defer fake.objectNameMutex.RUnlock()
	return len(fake.objectNameArgsForCall)
}

func (fake *FakeEvent) ObjectNameReturns(result1 string) {
	fake.ObjectNameStub = nil
	fake.objectNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeEvent) ObjectNameReturnsOnCall(i int, result1 string) {
	fake.ObjectNameStub = nil
	if fake.objectNameReturnsOnCall == nil {
		fake.objectNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.objectNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeEvent) TaskID() string {
	fake.taskIDMutex.Lock()
	ret, specificReturn := fake.taskIDReturnsOnCall[len(fake.taskIDArgsForCall)]
	fake.taskIDArgsForCall = append(fake.taskIDArgsForCall, struct{}{})
	fake.recordInvocation("TaskID", []interface{}{})
	fake.taskIDMutex.Unlock()
	if fake.TaskIDStub != nil {
		return fake.TaskIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.taskIDReturns.result1
}

func (fake *FakeEvent) TaskIDCallCount() int {
	fake.taskIDMutex.RLock()
	defer fake.taskIDMutex.RUnlock()
	return len(fake.taskIDArgsForCall)
}

func (fake *FakeEvent) TaskIDReturns(result1 string) {
	fake.TaskIDStub = nil
	fake.taskIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeEvent) TaskIDReturnsOnCall(i int, result1 string) {
	fake.TaskIDStub = nil
	if fake.taskIDReturnsOnCall == nil {
		fake.taskIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.taskIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeEvent) DeploymentName() string {
	fake.deploymentNameMutex.Lock()
	ret, specificReturn := fake.deploymentNameReturnsOnCall[len(fake.deploymentNameArgsForCall)]
	fake.deploymentNameArgsForCall = append(fake.deploymentNameArgsForCall, struct{}{})
	fake.recordInvocation("DeploymentName", []interface{}{})
	fake.deploymentNameMutex.Unlock()
	if fake.DeploymentNameStub != nil {
		return fake.DeploymentNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deploymentNameReturns.result1
}

func (fake *FakeEvent) DeploymentNameCallCount() int {
	fake.deploymentNameMutex.RLock()
	defer fake.deploymentNameMutex.RUnlock()
	return len(fake.deploymentNameArgsForCall)
}

func (fake *FakeEvent) DeploymentNameReturns(result1 string) {
	fake.DeploymentNameStub = nil
	fake.deploymentNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeEvent) DeploymentNameReturnsOnCall(i int, result1 string) {
	fake.DeploymentNameStub = nil
	if fake.deploymentNameReturnsOnCall == nil {
		fake.deploymentNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.deploymentNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeEvent) Instance() string {
	fake.instanceMutex.Lock()
	ret, specificReturn := fake.instanceReturnsOnCall[len(fake.instanceArgsForCall)]
	fake.instanceArgsForCall = append(fake.instanceArgsForCall, struct{}{})
	fake.recordInvocation("Instance", []interface{}{})
	fake.instanceMutex.Unlock()
	if fake.InstanceStub != nil {
		return fake.InstanceStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.instanceReturns.result1
}

func (fake *FakeEvent) InstanceCallCount() int {
	fake.instanceMutex.RLock()
	defer fake.instanceMutex.RUnlock()
	return len(fake.instanceArgsForCall)
}

func (fake *FakeEvent) InstanceReturns(result1 string) {
	fake.InstanceStub = nil
	fake.instanceReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeEvent) InstanceReturnsOnCall(i int, result1 string) {
	fake.InstanceStub = nil
	if fake.instanceReturnsOnCall == nil {
		fake.instanceReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.instanceReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeEvent) Context() map[string]interface{} {
	fake.contextMutex.Lock()
	ret, specificReturn := fake.contextReturnsOnCall[len(fake.contextArgsForCall)]
	fake.contextArgsForCall = append(fake.contextArgsForCall, struct{}{})
	fake.recordInvocation("Context", []interface{}{})
	fake.contextMutex.Unlock()
	if fake.ContextStub != nil {
		return fake.ContextStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.contextReturns.result1
}

func (fake *FakeEvent) ContextCallCount() int {
	fake.contextMutex.RLock()
	defer fake.contextMutex.RUnlock()
	return len(fake.contextArgsForCall)
}

func (fake *FakeEvent) ContextReturns(result1 map[string]interface{}) {
	fake.ContextStub = nil
	fake.contextReturns = struct {
		result1 map[string]interface{}
	}{result1}
}

func (fake *FakeEvent) ContextReturnsOnCall(i int, result1 map[string]interface{}) {
	fake.ContextStub = nil
	if fake.contextReturnsOnCall == nil {
		fake.contextReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
		})
	}
	fake.contextReturnsOnCall[i] = struct {
		result1 map[string]interface{}
	}{result1}
}

func (fake *FakeEvent) Error() string {
	fake.errorMutex.Lock()
	ret, specificReturn := fake.errorReturnsOnCall[len(fake.errorArgsForCall)]
	fake.errorArgsForCall = append(fake.errorArgsForCall, struct{}{})
	fake.recordInvocation("Error", []interface{}{})
	fake.errorMutex.Unlock()
	if fake.ErrorStub != nil {
		return fake.ErrorStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.errorReturns.result1
}

func (fake *FakeEvent) ErrorCallCount() int {
	fake.errorMutex.RLock()
	defer fake.errorMutex.RUnlock()
	return len(fake.errorArgsForCall)
}

func (fake *FakeEvent) ErrorReturns(result1 string) {
	fake.ErrorStub = nil
	fake.errorReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeEvent) ErrorReturnsOnCall(i int, result1 string) {
	fake.ErrorStub = nil
	if fake.errorReturnsOnCall == nil {
		fake.errorReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.errorReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeEvent) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.parentIDMutex.RLock()
	defer fake.parentIDMutex.RUnlock()
	fake.timestampMutex.RLock()
	defer fake.timestampMutex.RUnlock()
	fake.userMutex.RLock()
	defer fake.userMutex.RUnlock()
	fake.actionMutex.RLock()
	defer fake.actionMutex.RUnlock()
	fake.objectTypeMutex.RLock()
	defer fake.objectTypeMutex.RUnlock()
	fake.objectNameMutex.RLock()
	defer fake.objectNameMutex.RUnlock()
	fake.taskIDMutex.RLock()
	defer fake.taskIDMutex.RUnlock()
	fake.deploymentNameMutex.RLock()
	defer fake.deploymentNameMutex.RUnlock()
	fake.instanceMutex.RLock()
	defer fake.instanceMutex.RUnlock()
	fake.contextMutex.RLock()
	defer fake.contextMutex.RUnlock()
	fake.errorMutex.RLock()
	defer fake.errorMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeEvent) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ director.Event = new(FakeEvent)
