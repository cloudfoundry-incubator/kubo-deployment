// Code generated by counterfeiter. DO NOT EDIT.
package stemcellfakes

import (
	"sync"

	"github.com/cloudfoundry/bosh-cli/stemcell"
	biproperty "github.com/cloudfoundry/bosh-utils/property"
)

type FakeExtractedStemcell struct {
	ManifestStub        func() stemcell.Manifest
	manifestMutex       sync.RWMutex
	manifestArgsForCall []struct{}
	manifestReturns     struct {
		result1 stemcell.Manifest
	}
	manifestReturnsOnCall map[int]struct {
		result1 stemcell.Manifest
	}
	CleanupStub        func() error
	cleanupMutex       sync.RWMutex
	cleanupArgsForCall []struct{}
	cleanupReturns     struct {
		result1 error
	}
	cleanupReturnsOnCall map[int]struct {
		result1 error
	}
	OsAndVersionStub        func() string
	osAndVersionMutex       sync.RWMutex
	osAndVersionArgsForCall []struct{}
	osAndVersionReturns     struct {
		result1 string
	}
	osAndVersionReturnsOnCall map[int]struct {
		result1 string
	}
	SetNameStub        func(string)
	setNameMutex       sync.RWMutex
	setNameArgsForCall []struct {
		arg1 string
	}
	SetVersionStub        func(string)
	setVersionMutex       sync.RWMutex
	setVersionArgsForCall []struct {
		arg1 string
	}
	SetFormatStub        func([]string)
	setFormatMutex       sync.RWMutex
	setFormatArgsForCall []struct {
		arg1 []string
	}
	SetCloudPropertiesStub        func(biproperty.Map)
	setCloudPropertiesMutex       sync.RWMutex
	setCloudPropertiesArgsForCall []struct {
		arg1 biproperty.Map
	}
	GetExtractedPathStub        func() string
	getExtractedPathMutex       sync.RWMutex
	getExtractedPathArgsForCall []struct{}
	getExtractedPathReturns     struct {
		result1 string
	}
	getExtractedPathReturnsOnCall map[int]struct {
		result1 string
	}
	PackStub        func(string) error
	packMutex       sync.RWMutex
	packArgsForCall []struct {
		arg1 string
	}
	packReturns struct {
		result1 error
	}
	packReturnsOnCall map[int]struct {
		result1 error
	}
	EmptyImageStub        func() error
	emptyImageMutex       sync.RWMutex
	emptyImageArgsForCall []struct{}
	emptyImageReturns     struct {
		result1 error
	}
	emptyImageReturnsOnCall map[int]struct {
		result1 error
	}
	StringStub        func() string
	stringMutex       sync.RWMutex
	stringArgsForCall []struct{}
	stringReturns     struct {
		result1 string
	}
	stringReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeExtractedStemcell) Manifest() stemcell.Manifest {
	fake.manifestMutex.Lock()
	ret, specificReturn := fake.manifestReturnsOnCall[len(fake.manifestArgsForCall)]
	fake.manifestArgsForCall = append(fake.manifestArgsForCall, struct{}{})
	fake.recordInvocation("Manifest", []interface{}{})
	fake.manifestMutex.Unlock()
	if fake.ManifestStub != nil {
		return fake.ManifestStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.manifestReturns.result1
}

func (fake *FakeExtractedStemcell) ManifestCallCount() int {
	fake.manifestMutex.RLock()
	defer fake.manifestMutex.RUnlock()
	return len(fake.manifestArgsForCall)
}

func (fake *FakeExtractedStemcell) ManifestReturns(result1 stemcell.Manifest) {
	fake.ManifestStub = nil
	fake.manifestReturns = struct {
		result1 stemcell.Manifest
	}{result1}
}

func (fake *FakeExtractedStemcell) ManifestReturnsOnCall(i int, result1 stemcell.Manifest) {
	fake.ManifestStub = nil
	if fake.manifestReturnsOnCall == nil {
		fake.manifestReturnsOnCall = make(map[int]struct {
			result1 stemcell.Manifest
		})
	}
	fake.manifestReturnsOnCall[i] = struct {
		result1 stemcell.Manifest
	}{result1}
}

func (fake *FakeExtractedStemcell) Cleanup() error {
	fake.cleanupMutex.Lock()
	ret, specificReturn := fake.cleanupReturnsOnCall[len(fake.cleanupArgsForCall)]
	fake.cleanupArgsForCall = append(fake.cleanupArgsForCall, struct{}{})
	fake.recordInvocation("Cleanup", []interface{}{})
	fake.cleanupMutex.Unlock()
	if fake.CleanupStub != nil {
		return fake.CleanupStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cleanupReturns.result1
}

func (fake *FakeExtractedStemcell) CleanupCallCount() int {
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	return len(fake.cleanupArgsForCall)
}

func (fake *FakeExtractedStemcell) CleanupReturns(result1 error) {
	fake.CleanupStub = nil
	fake.cleanupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExtractedStemcell) CleanupReturnsOnCall(i int, result1 error) {
	fake.CleanupStub = nil
	if fake.cleanupReturnsOnCall == nil {
		fake.cleanupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cleanupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExtractedStemcell) OsAndVersion() string {
	fake.osAndVersionMutex.Lock()
	ret, specificReturn := fake.osAndVersionReturnsOnCall[len(fake.osAndVersionArgsForCall)]
	fake.osAndVersionArgsForCall = append(fake.osAndVersionArgsForCall, struct{}{})
	fake.recordInvocation("OsAndVersion", []interface{}{})
	fake.osAndVersionMutex.Unlock()
	if fake.OsAndVersionStub != nil {
		return fake.OsAndVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.osAndVersionReturns.result1
}

func (fake *FakeExtractedStemcell) OsAndVersionCallCount() int {
	fake.osAndVersionMutex.RLock()
	defer fake.osAndVersionMutex.RUnlock()
	return len(fake.osAndVersionArgsForCall)
}

func (fake *FakeExtractedStemcell) OsAndVersionReturns(result1 string) {
	fake.OsAndVersionStub = nil
	fake.osAndVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeExtractedStemcell) OsAndVersionReturnsOnCall(i int, result1 string) {
	fake.OsAndVersionStub = nil
	if fake.osAndVersionReturnsOnCall == nil {
		fake.osAndVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.osAndVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeExtractedStemcell) SetName(arg1 string) {
	fake.setNameMutex.Lock()
	fake.setNameArgsForCall = append(fake.setNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetName", []interface{}{arg1})
	fake.setNameMutex.Unlock()
	if fake.SetNameStub != nil {
		fake.SetNameStub(arg1)
	}
}

func (fake *FakeExtractedStemcell) SetNameCallCount() int {
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	return len(fake.setNameArgsForCall)
}

func (fake *FakeExtractedStemcell) SetNameArgsForCall(i int) string {
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	return fake.setNameArgsForCall[i].arg1
}

func (fake *FakeExtractedStemcell) SetVersion(arg1 string) {
	fake.setVersionMutex.Lock()
	fake.setVersionArgsForCall = append(fake.setVersionArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetVersion", []interface{}{arg1})
	fake.setVersionMutex.Unlock()
	if fake.SetVersionStub != nil {
		fake.SetVersionStub(arg1)
	}
}

func (fake *FakeExtractedStemcell) SetVersionCallCount() int {
	fake.setVersionMutex.RLock()
	defer fake.setVersionMutex.RUnlock()
	return len(fake.setVersionArgsForCall)
}

func (fake *FakeExtractedStemcell) SetVersionArgsForCall(i int) string {
	fake.setVersionMutex.RLock()
	defer fake.setVersionMutex.RUnlock()
	return fake.setVersionArgsForCall[i].arg1
}

func (fake *FakeExtractedStemcell) SetFormat(arg1 []string) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setFormatMutex.Lock()
	fake.setFormatArgsForCall = append(fake.setFormatArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	fake.recordInvocation("SetFormat", []interface{}{arg1Copy})
	fake.setFormatMutex.Unlock()
	if fake.SetFormatStub != nil {
		fake.SetFormatStub(arg1)
	}
}

func (fake *FakeExtractedStemcell) SetFormatCallCount() int {
	fake.setFormatMutex.RLock()
	defer fake.setFormatMutex.RUnlock()
	return len(fake.setFormatArgsForCall)
}

func (fake *FakeExtractedStemcell) SetFormatArgsForCall(i int) []string {
	fake.setFormatMutex.RLock()
	defer fake.setFormatMutex.RUnlock()
	return fake.setFormatArgsForCall[i].arg1
}

func (fake *FakeExtractedStemcell) SetCloudProperties(arg1 biproperty.Map) {
	fake.setCloudPropertiesMutex.Lock()
	fake.setCloudPropertiesArgsForCall = append(fake.setCloudPropertiesArgsForCall, struct {
		arg1 biproperty.Map
	}{arg1})
	fake.recordInvocation("SetCloudProperties", []interface{}{arg1})
	fake.setCloudPropertiesMutex.Unlock()
	if fake.SetCloudPropertiesStub != nil {
		fake.SetCloudPropertiesStub(arg1)
	}
}

func (fake *FakeExtractedStemcell) SetCloudPropertiesCallCount() int {
	fake.setCloudPropertiesMutex.RLock()
	defer fake.setCloudPropertiesMutex.RUnlock()
	return len(fake.setCloudPropertiesArgsForCall)
}

func (fake *FakeExtractedStemcell) SetCloudPropertiesArgsForCall(i int) biproperty.Map {
	fake.setCloudPropertiesMutex.RLock()
	defer fake.setCloudPropertiesMutex.RUnlock()
	return fake.setCloudPropertiesArgsForCall[i].arg1
}

func (fake *FakeExtractedStemcell) GetExtractedPath() string {
	fake.getExtractedPathMutex.Lock()
	ret, specificReturn := fake.getExtractedPathReturnsOnCall[len(fake.getExtractedPathArgsForCall)]
	fake.getExtractedPathArgsForCall = append(fake.getExtractedPathArgsForCall, struct{}{})
	fake.recordInvocation("GetExtractedPath", []interface{}{})
	fake.getExtractedPathMutex.Unlock()
	if fake.GetExtractedPathStub != nil {
		return fake.GetExtractedPathStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getExtractedPathReturns.result1
}

func (fake *FakeExtractedStemcell) GetExtractedPathCallCount() int {
	fake.getExtractedPathMutex.RLock()
	defer fake.getExtractedPathMutex.RUnlock()
	return len(fake.getExtractedPathArgsForCall)
}

func (fake *FakeExtractedStemcell) GetExtractedPathReturns(result1 string) {
	fake.GetExtractedPathStub = nil
	fake.getExtractedPathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeExtractedStemcell) GetExtractedPathReturnsOnCall(i int, result1 string) {
	fake.GetExtractedPathStub = nil
	if fake.getExtractedPathReturnsOnCall == nil {
		fake.getExtractedPathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getExtractedPathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeExtractedStemcell) Pack(arg1 string) error {
	fake.packMutex.Lock()
	ret, specificReturn := fake.packReturnsOnCall[len(fake.packArgsForCall)]
	fake.packArgsForCall = append(fake.packArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Pack", []interface{}{arg1})
	fake.packMutex.Unlock()
	if fake.PackStub != nil {
		return fake.PackStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.packReturns.result1
}

func (fake *FakeExtractedStemcell) PackCallCount() int {
	fake.packMutex.RLock()
	defer fake.packMutex.RUnlock()
	return len(fake.packArgsForCall)
}

func (fake *FakeExtractedStemcell) PackArgsForCall(i int) string {
	fake.packMutex.RLock()
	defer fake.packMutex.RUnlock()
	return fake.packArgsForCall[i].arg1
}

func (fake *FakeExtractedStemcell) PackReturns(result1 error) {
	fake.PackStub = nil
	fake.packReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExtractedStemcell) PackReturnsOnCall(i int, result1 error) {
	fake.PackStub = nil
	if fake.packReturnsOnCall == nil {
		fake.packReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.packReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExtractedStemcell) EmptyImage() error {
	fake.emptyImageMutex.Lock()
	ret, specificReturn := fake.emptyImageReturnsOnCall[len(fake.emptyImageArgsForCall)]
	fake.emptyImageArgsForCall = append(fake.emptyImageArgsForCall, struct{}{})
	fake.recordInvocation("EmptyImage", []interface{}{})
	fake.emptyImageMutex.Unlock()
	if fake.EmptyImageStub != nil {
		return fake.EmptyImageStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.emptyImageReturns.result1
}

func (fake *FakeExtractedStemcell) EmptyImageCallCount() int {
	fake.emptyImageMutex.RLock()
	defer fake.emptyImageMutex.RUnlock()
	return len(fake.emptyImageArgsForCall)
}

func (fake *FakeExtractedStemcell) EmptyImageReturns(result1 error) {
	fake.EmptyImageStub = nil
	fake.emptyImageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExtractedStemcell) EmptyImageReturnsOnCall(i int, result1 error) {
	fake.EmptyImageStub = nil
	if fake.emptyImageReturnsOnCall == nil {
		fake.emptyImageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.emptyImageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExtractedStemcell) String() string {
	fake.stringMutex.Lock()
	ret, specificReturn := fake.stringReturnsOnCall[len(fake.stringArgsForCall)]
	fake.stringArgsForCall = append(fake.stringArgsForCall, struct{}{})
	fake.recordInvocation("String", []interface{}{})
	fake.stringMutex.Unlock()
	if fake.StringStub != nil {
		return fake.StringStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.stringReturns.result1
}

func (fake *FakeExtractedStemcell) StringCallCount() int {
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	return len(fake.stringArgsForCall)
}

func (fake *FakeExtractedStemcell) StringReturns(result1 string) {
	fake.StringStub = nil
	fake.stringReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeExtractedStemcell) StringReturnsOnCall(i int, result1 string) {
	fake.StringStub = nil
	if fake.stringReturnsOnCall == nil {
		fake.stringReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.stringReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeExtractedStemcell) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.manifestMutex.RLock()
	defer fake.manifestMutex.RUnlock()
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	fake.osAndVersionMutex.RLock()
	defer fake.osAndVersionMutex.RUnlock()
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	fake.setVersionMutex.RLock()
	defer fake.setVersionMutex.RUnlock()
	fake.setFormatMutex.RLock()
	defer fake.setFormatMutex.RUnlock()
	fake.setCloudPropertiesMutex.RLock()
	defer fake.setCloudPropertiesMutex.RUnlock()
	fake.getExtractedPathMutex.RLock()
	defer fake.getExtractedPathMutex.RUnlock()
	fake.packMutex.RLock()
	defer fake.packMutex.RUnlock()
	fake.emptyImageMutex.RLock()
	defer fake.emptyImageMutex.RUnlock()
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeExtractedStemcell) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ stemcell.ExtractedStemcell = new(FakeExtractedStemcell)
